/*
 * Created on Jul 19, 2003
 */
package de.torstennahm.distribution;

import de.torstennahm.math.MathTN;
import de.torstennahm.math.VectorFunction;

/**
 * Creates Brownian paths from Gassian input using the the Brownian bridge
 * algorithm.
 * 
 * Specifically, the class converts input with the <i>n</i>-dimensional
 * Gaussian distibution to the distribution
 * of discretized brownian paths with <i>n</i> steps with the specified total variance
 * and starting point <i>x0</i>. The discretized Brownian path is represented by an
 * <i>n+1</i>-dimensional path array <code>x</code>, where <code>x[0]</code> represents
 * the path position at time 0 (this will always be <i>x0</i>),
 * <code>x[1]</code> the path position after step 1,
 * ..., and <code>x[n]</code> the final path position.
 * <p>
 * The number of steps <i>n</i> must be a power of 2, due to the implementation of
 * the Brownian Bridge algorithm.
 * <p>
 * Algorithmically, the path is generated by beginning with start and end point and then successively
 * splitting the time interval in two and interpolating the remaining points.
 * <p>
 * According to general <code>Function</code> contract, this class is thread-safe.
 * 
 * @author Torsten Nahm
 */

public class BrownianBridge extends VectorFunction {
	protected final double variance;
	protected final int steps;
	protected final int dimension;
	protected final boolean open;
	
	/**
	 * Constructs the function.
	 *  
	 * @param steps number of steps of the path
	 * @param variance total variance of the path
	 */			
	public BrownianBridge(double variance, int steps, boolean open) {
		if (steps != MathTN.binaryCeil(steps)) {
			throw new IllegalArgumentException("The number of time steps must be a power of 2");
		}
		
		this.variance = variance;
		this.steps = steps;
		this.open = open;
		dimension = open ? steps : steps - 1;
	}
		
	@Override
	public int inputDimension() {
		return dimension;
	}
	
	@Override
	public int outputDimension() {
		return steps + 1;
	}
	
	/**
	 * Produces the discretized Brownian path.
	 * 
	 * The discretized Brownian path is represented by an
	 * <i>n+1</i>-dimensional path array <code>x</code>, where <code>x[0]</code> represents
	 * the path position at time 0 (this will always be <i>x0</i>),
	 * <code>x[1]</code> the path position after step 1,
	 * ..., and <code>x[n]</code> the final path position.
	 * 
	 * @param x the <i>n</i>-dimensional gaussian noise
	 * @return the <i>n+1</i>-dimensional discretized path
	 */
	@Override
	public double[] evaluate(double[] x) {
		checkArgument(x);
		
		double[] path = new double[steps + 1];
		int i = 0;
		path[0] = 0.0;
		if (open) {
			path[steps] = Math.sqrt(variance) * x[i++];
		} else {
			path[steps] = path[0];
		}
			 
		for (int j = steps / 2; j >= 1; j /= 2) {
			double var = Math.sqrt(variance / steps * j * 0.5);
			for (int k = j; k < steps; k += 2 * j) {
				path[k] = 0.5 * (path[k - j] + path[k + j]) + var * x[i++];
			}
		}
		
		return path;
	}
	
	@Override
	public String toString() {
		return (open ? "" : "Closed ") + "Brownian Bridge(v=" + variance + ",steps=" + steps + ")"; 
	}
}